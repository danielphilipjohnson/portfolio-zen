---
title: "Understanding React Rendering: A Travel-Themed Deep Dive"
publishDate: "23/05/2025"
modifiedDate: "23/05/2025"
author:
  name: "Daniel Philip Johnson"
  role: "Full Stack Developer"
  avatar: "/images/profile.webp"
category: "Software Development"
readingTime: "12 min read"
tags:
  - "RSC"
  - "React Client Components"
  - "React hydration"
  - "Next.js rendering"
  - "React"
imageUrl: "/images/blog/react/travel-cover.webp"
excerpt: "Understand React rendering with our deep dive into Server Components, Client Components, and the hydration process. Learn to optimize your React apps for performance and interactivity."
---
import Quote from '@/components/ui/Quote'
import CodeBlock from '@/components/CodeBlock'


## TL;DR: React Rendering in One Sentence

Think of React rendering like planning a trip:

* 🧳 **Server Components** = Checked luggage (pre-packed, efficient, not interactive)
    
* 🎒 **Client Components** = Carry-on bags (interactive, accessible, but heavier)
    
* 🛃 **Hydration** = The immigration process (makes HTML interactive)
    
* ✈️ **Rendering** = Your flight (transit from code to UI)
    
* 🏨 **React Tree** = Your final destination (a fully interactive app)
    

Pack wisely, hydrate carefully, and enjoy the journey. ✈️

![](/images/blog/react/journey.webp)

## Your React Journey Map

Just like planning the perfect vacation, building a React application has key stages — from prepping your bags to arriving at your interactive destination.

Here's the full route ahead:

* ✅ **Pre-Trip Planning** – Understanding React's architecture and design patterns
    
* 🧳 **Packing Your Components** – Choosing what belongs in Server vs Client Components
    
* 🎫 **App Check-In** – Setting up your application and configuration
    
* ✈️ **Initial Render Flight** – Kicking off the rendering process
    
* 🛬 **HTML Arrival – HTML** is delivered to the browser
    
* 🛃 **Hydration Checkpoint** – Hydration breathes life into your static content
    
* 🚕 **State Activation** – Event handlers and state start flowing
    
* 🏨 **Fully Settled UI** – You've arrived: the fully interactive app is ready
    

With our bags packed and boarding pass ready, let's begin the journey through React rendering.

## 1. Packing Our Bags: Preparing for the Journey

Before our React adventure begins, let's understand what we're packing.

### The Essentials: What to Pack Server Components: The Checked Luggage

* Packed before the journey (executed on the server, but not full HTML like traditional SSR). Think of it as structured data rather than complete UI).
    
* **Optimised for performance and SEO** (reduces JavaScript sent to users).
    
* **Not interactive**—once checked in, you can't modify it during the flight.
    

<CodeBlock language="tsx">
{`
// A simple Server Component
async function DestinationInfo() {
  const data = await fetchDestinationData(); // Fetching on the server
  return <h1>Welcome to {data.city}!</h1>;
}

export default DestinationInfo;
`}
</CodeBlock>
<br/>

✅ Ideal for **static content, SEO, and pre-processed data.**

❌ Cannot handle **click events or local state.**

<Quote>
**Travel Tip**: Pack heavy, rarely-changing content in your checked luggage (Server Components). This makes your carry-on (Client Components) lighter and your journey smoother!

</Quote>

---

### Client Components: The Carry-On Bag

* **Kept with you during the flight**—handles **interactivity.**
    
* **Can change throughout the journey** (stateful updates).
    
* **Carries extra weight** (more JavaScript = slower load times).
    

<CodeBlock language="tsx">
{`
'use client'; // Marking it as a client component
import { useState } from "react";

function TravelChecklist() {
  const [checked, setChecked] = useState(false);

  return (
    <button onClick={() => setChecked(!checked)}>
      {checked ? "Checked In! ✅" : "Check In ✈️"}
    </button>
  );
}

export default TravelChecklist;
`}
</CodeBlock>
<br/>


💡 `'use client'` must be the **first line** in your file (before imports).  
It tells React that this file must run entirely on the client, enabling the use of state, effects, and browser APIs.

✅ Perfect for **user interactions and dynamic elements.**

❌ More JavaScript **means more performance overhead.**

<Quote>
**Travel Tip**: Keep your carry-on bag (Client Components) as light as possible! Only pack what you'll need during the flight (user interactions).
</Quote>


---

### The Virtual DOM: Your Travel Map

* A **blueprint** of your trip—React optimises rendering based on it.
    
* Determines **what changes need to be made** without unnecessary re-renders.
    
* Helps you navigate efficiently, just like a good travel map prevents wrong turns.
    

---

### Hydration: Unpacking at the Destination

* Server Components arrive as pre-rendered HTML. Hydration then reconnects them to interactivity.
    
* React **reconnects the HTML with event listeners and state management** to complete the process.
    

<CodeBlock language="tsx">
{`
// Server Component: Pre-rendered static content
async function WelcomeMessage() {
  return <h1>Welcome to React Island! 🏝️</h1>;
}

// Client Component: Hydration adds interactivity
'use client';
function ClickToExplore() {
  const [explored, setExplored] = useState(false);

  return (
    <button onClick={() => setExplored(true)}>
      {explored ? "Explored! 🌍" : "Start Exploring"}
    </button>
  );
}
`}
</CodeBlock>
<br/>

✅ **Reduces load times**—HTML is delivered first, and JavaScript follows.

❌ **Without hydration, client components won't work.**

---

## Check-in: Setting Up Your React Application

![](/images/blog/react/travel-info.png)


Configuring your React app is like checking in for your flight—set your routes, confirm your documents, and drop off unnecessary baggage.

### Dropping Off Your Luggage: Choosing Your Build Type

Like choosing between a direct flight or one with layovers, setting your build output determines **how your app runs**—as a static export or with a server.

#### ✈️ Option A: Static Export (Jamstack Style)

* Great for **blogs, portfolios, SPAs**.
    
* Generates `.html`, `.js`, and `.css` files in an `out/` folder.
    
* Can be hosted anywhere (Netlify, Vercel, S3, GitHub Pages).
    

<CodeBlock language="javascript">
{`
// next.config.js
/**
 * @type {import('next').NextConfig}
 */
const nextConfig = {
  output: 'export',
}
module.exports = nextConfig;
`}
</CodeBlock>
<br/>

> 💡 Run `next build && next export` to generate static files in `/out`.

**Metaphor**: You've packed light. Everything fits in your carry-on. No server-side help required.

---

#### 🛫 Option B: Server Output (App Router + RSC)

* Required for **React Server Components**, API routes, and dynamic SSR features.
    
* Hosted on Node.js platforms or edge runtimes.
    

<CodeBlock language="javascript">
{`
const nextConfig = {
  output: 'server', // Enables server-side logic
};
`}
</CodeBlock>
<br/>

> ⚠️ You can't use `output: 'export'` if you rely on server features like `async` Server Components or API routes.

**Metaphor**: You've checked your bags. The airline (your server) handles it from here.

---

#### Bonus Configuration

You can fine-tune your build setup like adjusting seat preferences:

<CodeBlock language="javascript">
{`
const nextConfig = {
  output: 'export',
  trailingSlash: true,         // /about → /about/
  skipTrailingSlashRedirect: true,
  distDir: 'dist',             // Custom output folder
};
`}
</CodeBlock>
<br/>

---

### Security Screening

* **TypeScript**: Confirms props match shape (like TSA validating your passport).
    
* **ESLint/Prettier**: Flags suspicious items before boarding (code smell detection).
    
* **Tests**: Your final pre-boarding check.
    

<CodeBlock language="typescript">
{`
type DestinationProps = {
  city: string;
  countryCode: string;
  arrivalDate: Date;
};

function Destination({ city, countryCode, arrivalDate }: DestinationProps) {
  return <div>Traveling to {city}, {countryCode}</div>;
}
`}
</CodeBlock>

### 🧠 Travel Tip:

Taking time during check-in (build setup + static/server config + prop validation) prevents issues once you're in the air.

<Quote>
🛫 *We've packed our bags and cleared security. Server Components are safely stowed below. Client Components? Tucked under your seat—ready to interact. Sit back. We're ready for takeoff.*

</Quote>


---

## 2. The Journey Begins: Boarding the React Plane

Now that we're checked in and ready, let's board our React flight!

### Departure: Initial Rendering

* React processes **Server Components first** (like a **pre-flight check**).
    
* **Client Components are prepared** for interactive elements.
    
* The rendering process begins, just like a plane taxiing before takeoff.
    

### Organising Routes & Navigation

* React **structures components** before rendering.
    
* **Server Components determine page layout** (like the flight path).
    
* **Client Components handle user actions** (like in-flight services).
    

<CodeBlock language="jsx">
{`
export default function TravelPage() {
  return (
    <div>
      <DestinationInfo /> {/* Server Component - pre-flight check */}
      <ClickToExplore /> {/* Client Component - in-flight service */}
    </div>
  );
}
`}
</CodeBlock>

### In-Flight Services: React's Runtime Features

While in transit (as the application runs):

* **Data fetching** (like meal service during the flight)
    
* **User interactions** (like the entertainment system)
    
* **State updates** (like flight announcements updating passengers)
    

<CodeBlock language="jsx">
{`
// React's Suspense coordinates these services, like flight attendants
<Suspense fallback={<LoadingIndicator />}>
  <TravelActivities userPreference={preference} />
</Suspense>
`}
</CodeBlock>
<br/>
**Travel Tip**: A smooth in-flight experience requires proper coordination between the preflight preparations (server rendering) and in-flight services (client interactivity)!


<Quote>
✈️ Cruising altitude reached. Server Components laid the path. Client Components just handed out snacks (read: event handlers). Next stop: React Island. Make sure your components are seatbelt-secured and lazy-loaded.
</Quote>

---

## 3. The Landing: Bringing the Page to Life

* **Server Components arrive as fully packed HTML** (like luggage arriving at baggage claim).
    
* **Client Components prepare for hydration** (like preparing to go through immigration).
    
* React ensures that all components arrive safely at their destination.
    

<CodeBlock language="jsx">
{`
function TravelExperience() {
  return (
    <div>
      <WelcomeMessage /> {/* Already in HTML form */}
      <ClickToExplore /> {/* Needs hydration to become interactive */}
    </div>
  );
}
`}
</CodeBlock>

<br/>

<Quote>
**Travel Tip**: The initial HTML load (landing) should feel quick and seamless. Keep critical visuals in Server Components for a fast "time to first paint"!

</Quote>

<br/>
---

## 4. Passing Through Immigration: The Hydration Process

![](/images/blog/react/travel-board.webp)

How does React bring static HTML to life? Think of this as **passing through immigration** at the airport!

### The Immigration Checkpoints

Immigration has multiple steps, just like hydration:

1. **Passport Control**: Matching DOM nodes to React components
    
2. **Identity Verification**: Setting up event listeners
    
3. **Customs Declaration**: Initialising state
    
4. **Health Check**: Running initial effects
    

<CodeBlock language="jsx">
{`
// Hydration stages illustrated
// 1. Static HTML arrives from server (pre-immigration)
<div id="explore-button">Start Exploring</div>

// 2. JavaScript reconnects to make it interactive (post-immigration)
const button = document.getElementById("explore-button");
button.addEventListener("click", () => startExploration());
`}
</CodeBlock>

### How Server Components Include Client Components

* Server Components **return placeholders for Client Components.**
    
* The **Client Component is hydrated separately** after the page loads.
    

<CodeBlock language="jsx">
{`
// Server Component that renders a Client Component
import ClickToExplore from "./ClickToExplore";

async function DestinationPage() {
  return (
    <div>
      <h1>Welcome to Bali! 🌴</h1>
      <ClickToExplore /> {/* Hydrates after render - goes through immigration */}
    </div>
  );
}

export default DestinationPage;
`}
</CodeBlock>
<br/>

✅ Server Components **"know" where Client Components go** but **don't execute them on the server.**

**Travel Tip**: Immigration (hydration) can take time - prioritise what needs to become interactive first!

<Quote>
🛬 "We've touched down! The view out the window? HTML—prerendered and pixel-perfect. But we still need passports stamped and local interactivity enabled. Get ready for hydration."
</Quote>

---

## Baggage Claim: Loading Additional Resources

After clearing immigration, it's time to collect your checked luggage and additional resources:

### Retrieving Your Resources

* **Loading additional data** (like picking up your checked bags)
    
* **Setting up routes** (like finding transportation to your hotel)
    
* **Establishing API connections** (like connecting with local contacts)
    

<CodeBlock language="jsx">
{`
// Dynamic imports as "baggage claim"
const LocalAttractions = React.lazy(() => import('./Attractions'));

function DestinationGuide() {
  return (
    <Suspense fallback={<p>Loading local attractions...</p>}>
      <LocalAttractions />
    </Suspense>
  );
}
`}
</CodeBlock>
<br/>

<Quote>
**Travel Tip**: Not all luggage needs to be claimed immediately! Use lazy loading to retrieve resources only when needed.
</Quote>


---

## 5. Reaching Our Destination: A Fully Grown React Tree

Congratulations! We've **arrived at our final destination**—a fully **hydrated, interactive React tree**.

* Server Components **provide structure and efficiency.**
    
* Client Components **enable interactivity.**
    
* Hydration **makes the experience seamless.**
    

### Growing the React Tree

* React ensures **each component fits properly.**
    
* Hydration **connects static content with interactivity.**
    
* The Virtual DOM acts as a blueprint, allowing React to update only the parts of the UI that actually change—keeping performance snappy.
    

<CodeBlock language="jsx">
{`
export default function FullPage() {
  return (
    <div>
      <DestinationHeader /> {/* Fast static content */}
      <InteractiveMap /> {/* Responsive user interactions */} 
      <TravelChecklist /> {/* State management */}
    </div>
  );
}
`}
</CodeBlock>
<br/>

<Quote>
🗺️ "Customs cleared. Bags claimed. The React Tree is interactive and bustling. Components are awake, routes are mapped, and your app is now alive. Go explore!"
</Quote>

## Return Journey: React's Re-rendering Process

When it's time to update your view (like booking a new excursion during your trip):

* **Check-in for return** (Trigger state update)
    
* **Security screening** (Diff algorithm checks what needs to change)
    
* **Boarding the update flight** (Component re-rendering)
    
* **Landing back in the DOM** (UI updates)
    

<CodeBlock language="jsx">
{`
function TripUpdate() {
  const [destination, setDestination] = useState('Bali');
  
  return (
    <div>
      <p>Current destination: {destination}</p>
      <button onClick={() => setDestination('Tokyo')}>
        Change destination
      </button>
    </div>
  );
}
`}
</CodeBlock>
<br/>

**Travel Tip**: Just like changing plans during a trip, React's re-rendering process is most efficient when you only change what's necessary!

<Quote>
🔁 "New plans? No problem. React's re-rendering process is standing by. Your carry-on (Client Components) can adapt in-flight. Just remember: only repack what you truly need."
</Quote>


---

## Travel Troubleshooting: When Your React Journey Hits Turbulence

Even the best-planned trips can encounter problems:

* **Missed connections** (Failed API calls)
    
* **Lost luggage** (Missing props)
    
* **Flight delays** (Performance issues)
    
* **Passport problems** (Authentication errors)
    

<CodeBlock language="jsx">
{`
// Error boundaries work like travel insurance
<ErrorBoundary fallback={<TravelAssistance />}>
  <YourApplication />
</ErrorBoundary>
`}
</CodeBlock>
<br/>

✈️ **Travel Tip**: Always have a backup plan! Error boundaries and fallback UI help ensure your users never get stranded.

<Quote>
🧳 "Not everything goes according to plan. If hydration stumbles, props go missing, or async requests go dark—React's Error Boundaries are your travel insurance. Don't code without coverage."
</Quote>

---

## FAQs: Common Travel Questions

1. **Do Server Components inside Client Components still get built on the server?**
    
    ✅ **Yes!** Server Components always run **on the server**, even when inside a Client Component.
    
    ❌ Once inside a Client Component, you cannot render Server Components. Only the reverse is true: Server Components can include Client Components.
    
2. **Why use Server Components if Client Components can do everything?**
    
    ✅ Server Components **reduce JavaScript, improve SEO, and optimise rendering.**
    
    ✅ Client Components **handle state, interactivity, and user interactions.**
    
3. **What happens if I try to use hooks in a Server Component?**
    
    ❌ This is like trying to access your carry-on bag after it's been stored in the overhead compartment during takeoff – it won't work! Hooks can only be used in Client Components.
    
4. **Can I convert a Server Component to a Client Component mid-journey?**
    
    ❌ No, the decision of whether a component is a Server or Client Component is made before the journey begins. You can't change luggage types mid-flight!
    

---

## Key Takeaways

* **Server Components = Checked Luggage** (Efficient, pre-packed, non-interactive).
    
* **Client Components = Carry-On Bags** (Interactive, accessible, but heavier).
    
* **Hydration = Immigration Process** that brings your application to life.
    
* **React Tree = Your Complete Travel Experience** from departure to destination.
    

---

## Final Thoughts

React's **Server and Client Components** work together **like a well-organised trip**. By understanding **what to pack where**, when to **check in** versus **carry on**, and how the **immigration process** works, we can create **fast, scalable, and maintainable** applications.

Just as a good traveller learns which items to check and which to keep handy, a good React developer learns to balance server and client rendering for the optimal user experience.

---

## Key Terminology: Your React Travel Dictionary

### React Core Concepts

* **React Components** – Reusable pieces of UI, either **Server Components (SCs)** or **Client Components (CCs)**.
    
* **Virtual DOM** – A lightweight **representation of the real DOM** that React uses to optimise updates.
    
* **Hydration** – The process of attaching **event listeners & interactivity** to a server-rendered page.
    

### Server vs. Client Concepts

* **Server Components (SCs)** – Render **on the server**, improve performance, and **don't handle interactivity**.
    
* **Client Components (CCs)** – Render **on the client**, allow **state & interactivity**, but add JavaScript weight.
    
* **Streaming** – Sending Server Components **progressively** instead of waiting for the full page to load.
    

### React Rendering & Performance

* **SSR (Server-Side Rendering)** – Rendering HTML **on the server** before sending it to the browser.
    
* **CSR (Client-Side Rendering)** – Rendering **entirely in the browser**, requiring more JavaScript execution.
    
* **Suspense** – A React feature that **pauses rendering** until data is ready and shows a fallback UI.
    
* **Lazy Loading** – Dynamically **loading components only when needed**, reducing initial page size.
    
* **Reconciliation** – React's diffing algorithm that **updates only changed parts of the UI**, improving efficiency.
    

### Data Fetching & State Management

* **React Query / SWR** – Libraries for **efficient data fetching & caching** in React.
    
* **Context API** – A built-in React feature for **sharing state** between components.
    
* **useState vs. useReducer** – `useState` is for **simple state**, while `useReducer` helps manage **complex logic**.
    

### Debugging & Error Handling

* **Error Boundaries** – Special components that **catch rendering errors** and show a fallback UI.
    
* **DevTools** – Chrome and React Developer Tools that **help inspect and debug components**.
    

### Security & Optimisation

* **Code Splitting** – Breaking JavaScript into smaller chunks **to improve loading speed**.
    
* **Tree Shaking** – Removing **unused code** during the build process.
    
* **Authentication & Authorisation** – Techniques for **securing user data and routes** in React apps.